# Chapter 01

## Item 01: View C++ as a federation of languages
C++ 언어는 관계가 있는 여러 언어들의 집합체(federation)이다.
- `C`
- `Object-Oriented C++`
- `Template C++`
- `STL`

### Things to remember
- C++를 사용한 효과적인 프로그래밍 규칙은 경우에 따라 달라진다. 그 경우란, 바로 `C++의 어떤 부분을 하용하느냐`이다.

## Item 02: Prefer consts, enums, and inlines to #defines
> 가급적 전처리기보다 컴파일러를 더 가까이 하자.

- #define은 전처리문이기 때문에 컴파일러에 코드가 도달하기 전에 전처리기가 상수로 처리한다. 그렇기 때문에 컴파일 에러가 났을 때, 에러 메세지에서 에러의 원인을 찾기 힘들다. (m1 mac 환경에서 clang++로 컴파일할 때는 보여준다.)
- 문자열 상수를 정의할 때는 const char * const 보다는 const std::string을 사용하자.

### enum hack
- 동작 방식이 const보다 #define에 더 가깝다.
- enum의 주소는 취하는 것이 불가능하기에 선언한 정수 상수를 가지고 주소나 레퍼런스를 사용하는 것이 싫다면 enum을 사용하자.
- 또한, 쓸데 없는 메모리를 사용하지 않는다.

### inline function
- 함수처럼 쓰이는 매크로를 만들고 싶다면, #define보다는 인라인 함수를 사용하자.
- 인라인 함수는 컴파일러가 함수 호출을 함수 본문으로 치환하는 것이다. 그렇기 때문에 함수 호출에 따른 오버헤드가 없다.

### Things to remember
- 단순한 상수를 쓸 때는, #define보다는 const 객체 혹은 enum을 우선 생각하자.
- 함수처럼 쓰이는 매크로로 만들려면, #define보다는 인라인 함수를 우선 생각하자.

## Item 03: Use const whenever possible
`const` 키워드
- 클래스 바깥에서 전역 혹은 네임스페이스 유효범위의 상수를 선언(정의)
- 파일, 함수, 블록 유효범위에서 static으로 선언한 객체에도 사용 가능
- 클래스 내부의 경우, 정적 멤버 및 비정적 데이터 멤버를 모두 상수로 선언 가능

### STL Iterator

### const function

### member function

#### bitwise constness(physical constness)
- 어떤 멤버함수가 그 객체의 어떤 데이터 멤버도 건드리지 않는다면 그 멤버 함수가 `const`임을 인정 (static 멤버는 제외)
- 상수성 위반을 발견하기 쉽다. 컴파일러가 데이터 멤버에 대해 대입 연산이 수행되었는지만 확인하면 된다.
- `포인터가 가리키는 대상의 상수성을 보장하지 않는다.` => logical constness가 등장한 이유
- C++에서 정의하는 `const`는 bitwise constness를 의미한다.

#### logical constness
- 상수 멤버 함수라고 해서 객체의 한 비트도 수정할 수 없는 것이 아니라 일부 몇 비트는 바꿀 수 있되, 그것을 사용자측에서 알아채지 못하게만 하면 상수 멤버 함수 자격이 있다는 것
- mutable 키워드를 사용하여 구현한다.

### Things to remember
- `const`를 붙여 선언하면 컴파일러가 사용상의 에러를 잡아내는 데 도움을 준다, `const`는 어떤 유효범위에 있는 객체에도 붙을 수 있으며, 함수 매개변수 및 반환 타입에도 붙을 수 있으며, 멤버 함수에도 붙을 수 있다.
- 컴파일러 쪽에서 보면 `비트수준 상수성`을 지켜야 하지만, 우리는 `개념적인(논리적인) 상수성`을 사용해서 프로그래밍해야 한다.
- 상수 멤버 및 비상수 멤버 함수가 기능적으로 서로 똑같게 구현되어 있을 경우에는 코드 중복을 피하는 것이 좋은데, 이 때 비상수 버전이 상수 버전을 호출하도록 만들어라.

## Item 04: Make sure that objects are initialized before they're used
- 어떤 상황에서는 선언한 객체가 확실히 초기화되지만(전역 객체, 정적 객체), 어떤 상황에서는 초기화되지 않을 수도 있다. (지역 객체, 비정적 객체)
- 초기화되지 않는 값을 읽도록 두면 미정의 동작(undefined behavior)이 발생하기 때문에 모든 객체를 사용하기 전에 항상 초기화하는 습관을 들이자.
- 기본제공 타입의 경우, 초기화를 손수해줘야 하고 C++ 초기화의 나머지 부분은 생성자로 귀결된다.
- 생성자에서 지킬 규칙은 지극히 간단하다. 그 객체의 모든 것을 초기화하면 된다.

### Member Initialization List
- 기본제공 타입의 멤버가 상수이거나 참조자로 되어 있는 경우 반드시 초기화 리스트를 사용해야 한다. 상수와 참조자는 대입 자체가 불가능하기 때문이다.

### Class Data Initialization Order
1. 기본 클래스는 파생 클래스보다 먼저 초기화된다.
2. 클래스 내의 멤버는 선언된 순서대로 초기화된다. => 초기화 리스트에서는 선언된 순서대로 나열하자.

### Static Object
`비지역 정적 객체의` 초기화 순서는 `개별 번역 단위`에서 정해진다.

Static Object의 범주는 다음과 같다.
1. 전역 객체
2. 네임스페이스 유효범위에서 정의된 객체
3. 클래스 안에서 static으로 선언된 객체
4. 함수 안에서 static으로 선언된 객체 (local static object)
5. 파일 유효범위에서 static으로 선언된 객체

`번역 단위(translation unit)`란, 컴파일러가 한 번에 컴파일하는 소스 파일의 묶음을 의미한다. (#include로 연결된 파일들을 모두 포함한 것)
**서로 다른 번역 단위에 정의된 비지역 정적 객체들의 상대적인 초기화 순서는 정의되어 있지 않다.**

`정적 객체 B`에게 의존성이 있는 `정적 객체 A`가 있다면, `정적 객체 A`를 `정적 객체 B`의 멤버로 만들거나 `정적 객체 A`를 `정적 객체 B` 안에서 함수의 지역 정적 객체로 만들어라.

### Things to remember
- 기본제공 타입의 객체는 직접 손으로 초기화하자. 경우에 따라 저절로 초기화되기도 하지만, 그렇지 않은 경우도 있기 때문이다.
- 생성자에서는 데이터 멤버에 대한 대입문을 생성자 본문 내부에 넣는 방식으로 초기화하지 말고 멤버 초기화 리스트(member initialization list)를 사용하자. 그리고 나열할 때는 선언된 순서대로 나열하자.
- 여러 번역 단위에 있는 비지역 정적 객체들의 초기화 순서 문제는 피해서 설계하자. 비지역 정적 객체를 지역 정적 객체로 바꾸면 된다.
